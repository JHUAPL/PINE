:py:mod:`pine.backend.job_manager.service`
==========================================

.. py:module:: pine.backend.job_manager.service


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   pine.backend.job_manager.service.ServiceJob
   pine.backend.job_manager.service.ServiceManager




Attributes
~~~~~~~~~~

.. autoapisummary::

   pine.backend.job_manager.service.config
   pine.backend.job_manager.service.logger
   pine.backend.job_manager.service.sm


.. py:data:: config
   

   

.. py:data:: logger
   

   

.. py:class:: ServiceJob(job_id: str, request_body: dict, request_response: dict)

   Bases: :py:obj:`object`

   Data class for a service job.

   "Constructor.

   :param job_id: str: job ID
   :param request_body: dict: job request body
   :param request_response: dict: job request response


.. py:class:: ServiceManager(default_handler=None)

   Bases: :py:obj:`object`

   
   :type default_handler: callable

   .. py:attribute:: r_pool
      

      

   .. py:attribute:: r_conn
      

      

   .. py:attribute:: redis_key_prefix
      

      

   .. py:attribute:: redis_reg_key_prefix
      

      

   .. py:attribute:: redis_channels_key
      

      

   .. py:attribute:: redis_channel_ttl_key_prefix
      

      

   .. py:attribute:: redis_work_queue_key_prefix
      

      

   .. py:attribute:: redis_work_mutex_key_prefix
      

      

   .. py:attribute:: redis_handler_mutex_key_prefix
      

      

   .. py:attribute:: redis_reg_key_ttl
      

      

   .. py:attribute:: redis_channels_key_ttl
      

      

   .. py:attribute:: redis_work_queue_key_ttl
      

      

   .. py:attribute:: redis_work_mutex_key_ttl
      

      

   .. py:attribute:: redis_handler_mutex_key_ttl
      

      

   .. py:attribute:: handler_timeout
      

      

   .. py:attribute:: registration_worker_name
      :annotation: = registration_worker

      

   .. py:attribute:: processing_worker_name
      :annotation: = processing_worker

      

   .. py:attribute:: channel_worker_name
      :annotation: = channel_worker

      

   .. py:attribute:: shutdown_channel
      :annotation: = shutdown

      

   .. py:attribute:: registration_channel
      :annotation: = registration

      

   .. py:attribute:: reserved_channels
      

      

   .. py:method:: get_results_key(cls, service_name: str, job_id: str) -> str
      :classmethod:


   .. py:method:: get_running_jobs_key(cls, service_name: str) -> str
      :classmethod:


   .. py:method:: get_registered_channels(cls, include_ttl=False)
      :classmethod:

      Get list of registered channels, with registration time if requested.
      :type include_ttl: bool
      :rtype: list[str] | dict[str, datetime]


   .. py:method:: get_registered_service_details(cls, service_name=None)
      :classmethod:

      Get registration details of a service.
      :type service_name: str
      :rtype: None | dict


   .. py:method:: get_registered_services(cls, include_details=True)
      :classmethod:

      Get list of registered services and registration body if requested.
      :type include_details: bool
      :rtype: list[str] | list[dict]


   .. py:method:: _get_service_details(cls, service_name: str, retry_count=10) -> dict
      :classmethod:


   .. py:method:: _get_service_channel(cls, service_name: str) -> str
      :classmethod:


   .. py:method:: send_service_request(cls, service_name: str, data, job_id=None, encoder=None)
      :classmethod:

      Queue's a job for the requested service.
      :type service_name: str
      :type data: dict
      :type job_id: str
      :type encoder: json.JSONEncoder
      :rtype: None | dict


   .. py:method:: get_job_response(cls, service_name: str, job_id: str, timeout_in_s: int)
      :classmethod:

      Waits for a response for the given job and returns it.
      :param service_name: str: service name
      :param job_id: str: job ID
      :param timeout_in_s: int: wait timeout in seconds
      :rtype None | dict


   .. py:method:: send_service_request_and_get_response(cls, service_name: str, data, timeout_in_s: int, job_id=None, encoder=None) -> ServiceJob
      :classmethod:

      Sends a service requests, waits for a response, and returns job data.
      :param service_name: str: service name
      :param data: job data
      :param timeout_in_s: int: wait timeout in seconds
      :param job_id: str: optional job ID (or None to auto-generate one)
      :param encoder: optional JSON encoder for job data
      :rtype None | ServiceJob


   .. py:method:: get_running_jobs(cls, service_name: str) -> List[str]
      :classmethod:

      Returns running jobs.
      :param service_name: str: service name
      :rtype list[str]


   .. py:method:: start_listeners(self)

      Starts all the workers.


   .. py:method:: stop_listeners(self)

      Stops all the workers.


   .. py:method:: _start_registration_listener(self)

      Starts the registration worker.
      :rtype: bool


   .. py:method:: _start_processing_listeners(self)

      Starts the processing workers.
      :rtype: bool


   .. py:method:: _start_channel_watchdog(self)

      Starts the channel watchdog workers in an asyncio-only thread. It monitors the channel TTL's.
      :rtype: bool


   .. py:method:: _stop_channel_watchdog(self)

      Stops the channel watchdog workers in an asyncio-only thread.
      :rtype: bool


   .. py:method:: _registration_listener(self)

      Registration Listener Implementation.


   .. py:method:: _channel_watchdog(self)
      :async:

      Channel Watchdog Implementation.
      In asyncio, it monitors the channel-ttl keys and the channels SET to expire registered services as needed.
      The other functionality is to register new channels as they're added to the pubsub in the processing listener.


   .. py:method:: _thread_killer(thread_id)
      :staticmethod:


   .. py:method:: _processing_listener_handler_wrapper(self, job_id, job_type, job_queue, job_data)


   .. py:method:: _processing_listener(self)

      Processing Listener Implementation.
      Runs a handler when a processing message gets send over an already registered channel.



.. py:data:: sm
   

   

